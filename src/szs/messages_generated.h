// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGES_SZS_MESSAGES_H_
#define FLATBUFFERS_GENERATED_MESSAGES_SZS_MESSAGES_H_

#include "flatbuffers/flatbuffers.h"

namespace szs {
namespace messages {

struct Packet;

struct Request;

struct Response;

struct OpenArchiveRequest;

struct OpenArchiveResponse;

struct InStreamReadRequest;

struct InStreamReadResponse;

struct InStreamSeekRequest;

struct InStreamSeekResponse;

struct ArchiveGetItemCountRequest;

struct ArchiveGetItemCountResponse;

struct ArchiveCloseRequest;

struct ArchiveCloseResponse;

struct Error;

enum Message {
  Message_NONE = 0,
  Message_Request = 1,
  Message_Response = 2,
  Message_MIN = Message_NONE,
  Message_MAX = Message_Response
};

inline const char **EnumNamesMessage() {
  static const char *names[] = {
    "NONE",
    "Request",
    "Response",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<Request> {
  static const Message enum_value = Message_Request;
};

template<> struct MessageTraits<Response> {
  static const Message enum_value = Message_Response;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum RequestParams {
  RequestParams_NONE = 0,
  RequestParams_OpenArchiveRequest = 1,
  RequestParams_InStreamReadRequest = 2,
  RequestParams_InStreamSeekRequest = 3,
  RequestParams_ArchiveGetItemCountRequest = 4,
  RequestParams_ArchiveCloseRequest = 5,
  RequestParams_MIN = RequestParams_NONE,
  RequestParams_MAX = RequestParams_ArchiveCloseRequest
};

inline const char **EnumNamesRequestParams() {
  static const char *names[] = {
    "NONE",
    "OpenArchiveRequest",
    "InStreamReadRequest",
    "InStreamSeekRequest",
    "ArchiveGetItemCountRequest",
    "ArchiveCloseRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestParams(RequestParams e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRequestParams()[index];
}

template<typename T> struct RequestParamsTraits {
  static const RequestParams enum_value = RequestParams_NONE;
};

template<> struct RequestParamsTraits<OpenArchiveRequest> {
  static const RequestParams enum_value = RequestParams_OpenArchiveRequest;
};

template<> struct RequestParamsTraits<InStreamReadRequest> {
  static const RequestParams enum_value = RequestParams_InStreamReadRequest;
};

template<> struct RequestParamsTraits<InStreamSeekRequest> {
  static const RequestParams enum_value = RequestParams_InStreamSeekRequest;
};

template<> struct RequestParamsTraits<ArchiveGetItemCountRequest> {
  static const RequestParams enum_value = RequestParams_ArchiveGetItemCountRequest;
};

template<> struct RequestParamsTraits<ArchiveCloseRequest> {
  static const RequestParams enum_value = RequestParams_ArchiveCloseRequest;
};

bool VerifyRequestParams(flatbuffers::Verifier &verifier, const void *obj, RequestParams type);
bool VerifyRequestParamsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ResponseResult {
  ResponseResult_NONE = 0,
  ResponseResult_OpenArchiveResponse = 1,
  ResponseResult_InStreamReadResponse = 2,
  ResponseResult_InStreamSeekResponse = 3,
  ResponseResult_ArchiveGetItemCountResponse = 4,
  ResponseResult_ArchiveCloseResponse = 5,
  ResponseResult_MIN = ResponseResult_NONE,
  ResponseResult_MAX = ResponseResult_ArchiveCloseResponse
};

inline const char **EnumNamesResponseResult() {
  static const char *names[] = {
    "NONE",
    "OpenArchiveResponse",
    "InStreamReadResponse",
    "InStreamSeekResponse",
    "ArchiveGetItemCountResponse",
    "ArchiveCloseResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseResult(ResponseResult e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResponseResult()[index];
}

template<typename T> struct ResponseResultTraits {
  static const ResponseResult enum_value = ResponseResult_NONE;
};

template<> struct ResponseResultTraits<OpenArchiveResponse> {
  static const ResponseResult enum_value = ResponseResult_OpenArchiveResponse;
};

template<> struct ResponseResultTraits<InStreamReadResponse> {
  static const ResponseResult enum_value = ResponseResult_InStreamReadResponse;
};

template<> struct ResponseResultTraits<InStreamSeekResponse> {
  static const ResponseResult enum_value = ResponseResult_InStreamSeekResponse;
};

template<> struct ResponseResultTraits<ArchiveGetItemCountResponse> {
  static const ResponseResult enum_value = ResponseResult_ArchiveGetItemCountResponse;
};

template<> struct ResponseResultTraits<ArchiveCloseResponse> {
  static const ResponseResult enum_value = ResponseResult_ArchiveCloseResponse;
};

bool VerifyResponseResult(flatbuffers::Verifier &verifier, const void *obj, ResponseResult type);
bool VerifyResponseResultVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Whence {
  Whence_SET = 0,
  Whence_CUR = 1,
  Whence_END = 2,
  Whence_MIN = Whence_SET,
  Whence_MAX = Whence_END
};

inline const char **EnumNamesWhence() {
  static const char *names[] = {
    "SET",
    "CUR",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameWhence(Whence e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesWhence()[index];
}

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Message message_type() const {
    return static_cast<Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

struct PacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Message message_type) {
    fbb_.AddElement<uint8_t>(Packet::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Packet::VT_MESSAGE, message);
  }
  PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Packet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    Message message_type = Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_METHOD = 4,
    VT_PARAMS_TYPE = 6,
    VT_PARAMS = 8,
    VT_ID = 10
  };
  const flatbuffers::String *method() const {
    return GetPointer<const flatbuffers::String *>(VT_METHOD);
  }
  RequestParams params_type() const {
    return static_cast<RequestParams>(GetField<uint8_t>(VT_PARAMS_TYPE, 0));
  }
  const void *params() const {
    return GetPointer<const void *>(VT_PARAMS);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_METHOD) &&
           verifier.Verify(method()) &&
           VerifyField<uint8_t>(verifier, VT_PARAMS_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PARAMS) &&
           VerifyRequestParams(verifier, params(), params_type()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(flatbuffers::Offset<flatbuffers::String> method) {
    fbb_.AddOffset(Request::VT_METHOD, method);
  }
  void add_params_type(RequestParams params_type) {
    fbb_.AddElement<uint8_t>(Request::VT_PARAMS_TYPE, static_cast<uint8_t>(params_type), 0);
  }
  void add_params(flatbuffers::Offset<void> params) {
    fbb_.AddOffset(Request::VT_PARAMS, params);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Request::VT_ID, id, 0);
  }
  RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> method = 0,
    RequestParams params_type = RequestParams_NONE,
    flatbuffers::Offset<void> params = 0,
    int32_t id = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_params(params);
  builder_.add_method(method);
  builder_.add_params_type(params_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *method = nullptr,
    RequestParams params_type = RequestParams_NONE,
    flatbuffers::Offset<void> params = 0,
    int32_t id = 0) {
  return szs::messages::CreateRequest(
      _fbb,
      method ? _fbb.CreateString(method) : 0,
      params_type,
      params,
      id);
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESULT_TYPE = 4,
    VT_RESULT = 6,
    VT_ERROR = 8,
    VT_ID = 10
  };
  ResponseResult result_type() const {
    return static_cast<ResponseResult>(GetField<uint8_t>(VT_RESULT_TYPE, 0));
  }
  const void *result() const {
    return GetPointer<const void *>(VT_RESULT);
  }
  const Error *error() const {
    return GetPointer<const Error *>(VT_ERROR);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RESULT) &&
           VerifyResponseResult(verifier, result(), result_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result_type(ResponseResult result_type) {
    fbb_.AddElement<uint8_t>(Response::VT_RESULT_TYPE, static_cast<uint8_t>(result_type), 0);
  }
  void add_result(flatbuffers::Offset<void> result) {
    fbb_.AddOffset(Response::VT_RESULT, result);
  }
  void add_error(flatbuffers::Offset<Error> error) {
    fbb_.AddOffset(Response::VT_ERROR, error);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Response::VT_ID, id, 0);
  }
  ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    ResponseResult result_type = ResponseResult_NONE,
    flatbuffers::Offset<void> result = 0,
    flatbuffers::Offset<Error> error = 0,
    int32_t id = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_error(error);
  builder_.add_result(result);
  builder_.add_result_type(result_type);
  return builder_.Finish();
}

struct OpenArchiveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IN_STREAM_ID = 4,
    VT_SIZE = 6,
    VT_EXT = 8
  };
  int32_t in_stream_id() const {
    return GetField<int32_t>(VT_IN_STREAM_ID, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  const flatbuffers::String *ext() const {
    return GetPointer<const flatbuffers::String *>(VT_EXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IN_STREAM_ID) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EXT) &&
           verifier.Verify(ext()) &&
           verifier.EndTable();
  }
};

struct OpenArchiveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_stream_id(int32_t in_stream_id) {
    fbb_.AddElement<int32_t>(OpenArchiveRequest::VT_IN_STREAM_ID, in_stream_id, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(OpenArchiveRequest::VT_SIZE, size, 0);
  }
  void add_ext(flatbuffers::Offset<flatbuffers::String> ext) {
    fbb_.AddOffset(OpenArchiveRequest::VT_EXT, ext);
  }
  OpenArchiveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpenArchiveRequestBuilder &operator=(const OpenArchiveRequestBuilder &);
  flatbuffers::Offset<OpenArchiveRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<OpenArchiveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpenArchiveRequest> CreateOpenArchiveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t in_stream_id = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::String> ext = 0) {
  OpenArchiveRequestBuilder builder_(_fbb);
  builder_.add_ext(ext);
  builder_.add_size(size);
  builder_.add_in_stream_id(in_stream_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpenArchiveRequest> CreateOpenArchiveRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t in_stream_id = 0,
    uint32_t size = 0,
    const char *ext = nullptr) {
  return szs::messages::CreateOpenArchiveRequest(
      _fbb,
      in_stream_id,
      size,
      ext ? _fbb.CreateString(ext) : 0);
}

struct OpenArchiveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ARCHIVE_ID = 4
  };
  int32_t archive_id() const {
    return GetField<int32_t>(VT_ARCHIVE_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ARCHIVE_ID) &&
           verifier.EndTable();
  }
};

struct OpenArchiveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_archive_id(int32_t archive_id) {
    fbb_.AddElement<int32_t>(OpenArchiveResponse::VT_ARCHIVE_ID, archive_id, 0);
  }
  OpenArchiveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpenArchiveResponseBuilder &operator=(const OpenArchiveResponseBuilder &);
  flatbuffers::Offset<OpenArchiveResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<OpenArchiveResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpenArchiveResponse> CreateOpenArchiveResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t archive_id = 0) {
  OpenArchiveResponseBuilder builder_(_fbb);
  builder_.add_archive_id(archive_id);
  return builder_.Finish();
}

struct InStreamReadRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IN_STREAM_ID = 4,
    VT_SIZE = 6
  };
  int32_t in_stream_id() const {
    return GetField<int32_t>(VT_IN_STREAM_ID, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IN_STREAM_ID) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct InStreamReadRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_stream_id(int32_t in_stream_id) {
    fbb_.AddElement<int32_t>(InStreamReadRequest::VT_IN_STREAM_ID, in_stream_id, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(InStreamReadRequest::VT_SIZE, size, 0);
  }
  InStreamReadRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InStreamReadRequestBuilder &operator=(const InStreamReadRequestBuilder &);
  flatbuffers::Offset<InStreamReadRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<InStreamReadRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InStreamReadRequest> CreateInStreamReadRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t in_stream_id = 0,
    uint32_t size = 0) {
  InStreamReadRequestBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_in_stream_id(in_stream_id);
  return builder_.Finish();
}

struct InStreamReadResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EXT = 4,
    VT_DATA = 6,
    VT_PROCESSED_SIZE = 8
  };
  const flatbuffers::String *ext() const {
    return GetPointer<const flatbuffers::String *>(VT_EXT);
  }
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  uint32_t processed_size() const {
    return GetField<uint32_t>(VT_PROCESSED_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EXT) &&
           verifier.Verify(ext()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyField<uint32_t>(verifier, VT_PROCESSED_SIZE) &&
           verifier.EndTable();
  }
};

struct InStreamReadResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ext(flatbuffers::Offset<flatbuffers::String> ext) {
    fbb_.AddOffset(InStreamReadResponse::VT_EXT, ext);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(InStreamReadResponse::VT_DATA, data);
  }
  void add_processed_size(uint32_t processed_size) {
    fbb_.AddElement<uint32_t>(InStreamReadResponse::VT_PROCESSED_SIZE, processed_size, 0);
  }
  InStreamReadResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InStreamReadResponseBuilder &operator=(const InStreamReadResponseBuilder &);
  flatbuffers::Offset<InStreamReadResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<InStreamReadResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InStreamReadResponse> CreateInStreamReadResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ext = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0,
    uint32_t processed_size = 0) {
  InStreamReadResponseBuilder builder_(_fbb);
  builder_.add_processed_size(processed_size);
  builder_.add_data(data);
  builder_.add_ext(ext);
  return builder_.Finish();
}

inline flatbuffers::Offset<InStreamReadResponse> CreateInStreamReadResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ext = nullptr,
    const std::vector<int8_t> *data = nullptr,
    uint32_t processed_size = 0) {
  return szs::messages::CreateInStreamReadResponse(
      _fbb,
      ext ? _fbb.CreateString(ext) : 0,
      data ? _fbb.CreateVector<int8_t>(*data) : 0,
      processed_size);
}

struct InStreamSeekRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IN_STREAM_ID = 4,
    VT_OFFSET = 6,
    VT_WHENCE = 8
  };
  int32_t in_stream_id() const {
    return GetField<int32_t>(VT_IN_STREAM_ID, 0);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  Whence whence() const {
    return static_cast<Whence>(GetField<int32_t>(VT_WHENCE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IN_STREAM_ID) &&
           VerifyField<int32_t>(verifier, VT_OFFSET) &&
           VerifyField<int32_t>(verifier, VT_WHENCE) &&
           verifier.EndTable();
  }
};

struct InStreamSeekRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_stream_id(int32_t in_stream_id) {
    fbb_.AddElement<int32_t>(InStreamSeekRequest::VT_IN_STREAM_ID, in_stream_id, 0);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(InStreamSeekRequest::VT_OFFSET, offset, 0);
  }
  void add_whence(Whence whence) {
    fbb_.AddElement<int32_t>(InStreamSeekRequest::VT_WHENCE, static_cast<int32_t>(whence), 0);
  }
  InStreamSeekRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InStreamSeekRequestBuilder &operator=(const InStreamSeekRequestBuilder &);
  flatbuffers::Offset<InStreamSeekRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<InStreamSeekRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InStreamSeekRequest> CreateInStreamSeekRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t in_stream_id = 0,
    int32_t offset = 0,
    Whence whence = Whence_SET) {
  InStreamSeekRequestBuilder builder_(_fbb);
  builder_.add_whence(whence);
  builder_.add_offset(offset);
  builder_.add_in_stream_id(in_stream_id);
  return builder_.Finish();
}

struct InStreamSeekResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NEW_POSITION = 4
  };
  int32_t new_position() const {
    return GetField<int32_t>(VT_NEW_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NEW_POSITION) &&
           verifier.EndTable();
  }
};

struct InStreamSeekResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_position(int32_t new_position) {
    fbb_.AddElement<int32_t>(InStreamSeekResponse::VT_NEW_POSITION, new_position, 0);
  }
  InStreamSeekResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InStreamSeekResponseBuilder &operator=(const InStreamSeekResponseBuilder &);
  flatbuffers::Offset<InStreamSeekResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<InStreamSeekResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InStreamSeekResponse> CreateInStreamSeekResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t new_position = 0) {
  InStreamSeekResponseBuilder builder_(_fbb);
  builder_.add_new_position(new_position);
  return builder_.Finish();
}

struct ArchiveGetItemCountRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ARCHIVE_ID = 4
  };
  int32_t archive_id() const {
    return GetField<int32_t>(VT_ARCHIVE_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ARCHIVE_ID) &&
           verifier.EndTable();
  }
};

struct ArchiveGetItemCountRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_archive_id(int32_t archive_id) {
    fbb_.AddElement<int32_t>(ArchiveGetItemCountRequest::VT_ARCHIVE_ID, archive_id, 0);
  }
  ArchiveGetItemCountRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArchiveGetItemCountRequestBuilder &operator=(const ArchiveGetItemCountRequestBuilder &);
  flatbuffers::Offset<ArchiveGetItemCountRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ArchiveGetItemCountRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArchiveGetItemCountRequest> CreateArchiveGetItemCountRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t archive_id = 0) {
  ArchiveGetItemCountRequestBuilder builder_(_fbb);
  builder_.add_archive_id(archive_id);
  return builder_.Finish();
}

struct ArchiveGetItemCountResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUM_ITEMS = 4
  };
  int32_t num_items() const {
    return GetField<int32_t>(VT_NUM_ITEMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_ITEMS) &&
           verifier.EndTable();
  }
};

struct ArchiveGetItemCountResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_items(int32_t num_items) {
    fbb_.AddElement<int32_t>(ArchiveGetItemCountResponse::VT_NUM_ITEMS, num_items, 0);
  }
  ArchiveGetItemCountResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArchiveGetItemCountResponseBuilder &operator=(const ArchiveGetItemCountResponseBuilder &);
  flatbuffers::Offset<ArchiveGetItemCountResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ArchiveGetItemCountResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArchiveGetItemCountResponse> CreateArchiveGetItemCountResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_items = 0) {
  ArchiveGetItemCountResponseBuilder builder_(_fbb);
  builder_.add_num_items(num_items);
  return builder_.Finish();
}

struct ArchiveCloseRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ARCHIVE_ID = 4
  };
  int32_t archive_id() const {
    return GetField<int32_t>(VT_ARCHIVE_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ARCHIVE_ID) &&
           verifier.EndTable();
  }
};

struct ArchiveCloseRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_archive_id(int32_t archive_id) {
    fbb_.AddElement<int32_t>(ArchiveCloseRequest::VT_ARCHIVE_ID, archive_id, 0);
  }
  ArchiveCloseRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArchiveCloseRequestBuilder &operator=(const ArchiveCloseRequestBuilder &);
  flatbuffers::Offset<ArchiveCloseRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ArchiveCloseRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArchiveCloseRequest> CreateArchiveCloseRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t archive_id = 0) {
  ArchiveCloseRequestBuilder builder_(_fbb);
  builder_.add_archive_id(archive_id);
  return builder_.Finish();
}

struct ArchiveCloseResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ArchiveCloseResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  ArchiveCloseResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArchiveCloseResponseBuilder &operator=(const ArchiveCloseResponseBuilder &);
  flatbuffers::Offset<ArchiveCloseResponse> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<ArchiveCloseResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArchiveCloseResponse> CreateArchiveCloseResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ArchiveCloseResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE = 4,
    VT_MESSAGE = 6
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
};

struct ErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(Error::VT_CODE, code, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Error::VT_MESSAGE, message);
  }
  ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorBuilder &operator=(const ErrorBuilder &);
  flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline flatbuffers::Offset<Error> CreateError(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    const char *message = nullptr) {
  return szs::messages::CreateError(
      _fbb,
      code,
      message ? _fbb.CreateString(message) : 0);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_Request: {
      auto ptr = reinterpret_cast<const Request *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Response: {
      auto ptr = reinterpret_cast<const Response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRequestParams(flatbuffers::Verifier &verifier, const void *obj, RequestParams type) {
  switch (type) {
    case RequestParams_NONE: {
      return true;
    }
    case RequestParams_OpenArchiveRequest: {
      auto ptr = reinterpret_cast<const OpenArchiveRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestParams_InStreamReadRequest: {
      auto ptr = reinterpret_cast<const InStreamReadRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestParams_InStreamSeekRequest: {
      auto ptr = reinterpret_cast<const InStreamSeekRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestParams_ArchiveGetItemCountRequest: {
      auto ptr = reinterpret_cast<const ArchiveGetItemCountRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestParams_ArchiveCloseRequest: {
      auto ptr = reinterpret_cast<const ArchiveCloseRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyRequestParamsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequestParams(
        verifier,  values->Get(i), types->GetEnum<RequestParams>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponseResult(flatbuffers::Verifier &verifier, const void *obj, ResponseResult type) {
  switch (type) {
    case ResponseResult_NONE: {
      return true;
    }
    case ResponseResult_OpenArchiveResponse: {
      auto ptr = reinterpret_cast<const OpenArchiveResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseResult_InStreamReadResponse: {
      auto ptr = reinterpret_cast<const InStreamReadResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseResult_InStreamSeekResponse: {
      auto ptr = reinterpret_cast<const InStreamSeekResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseResult_ArchiveGetItemCountResponse: {
      auto ptr = reinterpret_cast<const ArchiveGetItemCountResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseResult_ArchiveCloseResponse: {
      auto ptr = reinterpret_cast<const ArchiveCloseResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResponseResultVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponseResult(
        verifier,  values->Get(i), types->GetEnum<ResponseResult>(i))) {
      return false;
    }
  }
  return true;
}

inline const szs::messages::Packet *GetPacket(const void *buf) {
  return flatbuffers::GetRoot<szs::messages::Packet>(buf);
}

inline bool VerifyPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<szs::messages::Packet>(nullptr);
}

inline void FinishPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<szs::messages::Packet> root) {
  fbb.Finish(root);
}

}  // namespace messages
}  // namespace szs

#endif  // FLATBUFFERS_GENERATED_MESSAGES_SZS_MESSAGES_H_
